// Code generated by Remoto; DO NOT EDIT.

package client

import (
	"context"
	"encoding/json"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"strconv"

	"github.com/machinebox/remoto/remototypes"
	"github.com/oxtoacart/bpool"
	"github.com/pkg/errors"
)

// OrchestratorClient accesses remote Orchestrator services.
type OrchestratorClient struct {
	// endpoint is the HTTP endpoint of the remote server.
	endpoint string
	// httpclient is the http.Client to use to make requests.
	httpclient *http.Client
	// bufs is a buffer pool
	bufs *bpool.BufferPool
}

// NewOrchestratorClient makes a new OrchestratorClient that will
// use the specified http.Client to make requests.
func NewOrchestratorClient(endpoint string, client *http.Client) *OrchestratorClient {
	return &OrchestratorClient{
		endpoint:   endpoint,
		httpclient: client,
		bufs:       bpool.NewBufferPool(48),
	}
}

func (c *OrchestratorClient) Feedback(ctx context.Context, request *FeedbackRequest) (*Response, error) {
	resp, err := c.FeedbackMulti(ctx, []*FeedbackRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("OrchestratorClient.Feedback: no response")
	}
	return resp[0], nil
}

func (c *OrchestratorClient) FeedbackMulti(ctx context.Context, requests []*FeedbackRequest) ([]*Response, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Feedback: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "OrchestratorClient.Feedback: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "OrchestratorClient.Feedback: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Feedback: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Orchestrator.Feedback", buf)
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Feedback: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Feedback: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("OrchestratorClient.Feedback: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Feedback: read response body")
	}
	var resps []*Response
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Feedback: decode response body")
	}
	return resps, nil
}

func (c *OrchestratorClient) Next(ctx context.Context, request *NextRequest) (*Response, error) {
	resp, err := c.NextMulti(ctx, []*NextRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("OrchestratorClient.Next: no response")
	}
	return resp[0], nil
}

func (c *OrchestratorClient) NextMulti(ctx context.Context, requests []*NextRequest) ([]*Response, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Next: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "OrchestratorClient.Next: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "OrchestratorClient.Next: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Next: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Orchestrator.Next", buf)
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Next: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Next: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("OrchestratorClient.Next: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Next: read response body")
	}
	var resps []*Response
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Next: decode response body")
	}
	return resps, nil
}

func (c *OrchestratorClient) Rollback(ctx context.Context, request *RollbackRequest) (*Response, error) {
	resp, err := c.RollbackMulti(ctx, []*RollbackRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("OrchestratorClient.Rollback: no response")
	}
	return resp[0], nil
}

func (c *OrchestratorClient) RollbackMulti(ctx context.Context, requests []*RollbackRequest) ([]*Response, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Rollback: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "OrchestratorClient.Rollback: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "OrchestratorClient.Rollback: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Rollback: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Orchestrator.Rollback", buf)
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Rollback: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Rollback: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("OrchestratorClient.Rollback: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Rollback: read response body")
	}
	var resps []*Response
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Rollback: decode response body")
	}
	return resps, nil
}

func (c *OrchestratorClient) Start(ctx context.Context, request *StartRequest) (*Response, error) {
	resp, err := c.StartMulti(ctx, []*StartRequest{request})
	if err != nil {
		return nil, err
	}
	if len(resp) == 0 {
		return nil, errors.New("OrchestratorClient.Start: no response")
	}
	return resp[0], nil
}

func (c *OrchestratorClient) StartMulti(ctx context.Context, requests []*StartRequest) ([]*Response, error) {
	b, err := json.Marshal(requests)
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Start: encode request")
	}
	buf := c.bufs.Get()
	defer c.bufs.Put(buf)
	w := multipart.NewWriter(buf)
	w.WriteField("json", string(b))
	if files, ok := ctx.Value(contextKeyFiles).(map[string]file); ok {
		for fieldname, file := range files {
			f, err := w.CreateFormFile(fieldname, file.filename)
			if err != nil {
				return nil, errors.Wrap(err, "OrchestratorClient.Start: create form file")
			}
			if _, err := io.Copy(f, file.r); err != nil {
				return nil, errors.Wrap(err, "OrchestratorClient.Start: reading file")
			}
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
		}
	}
	if err := w.Close(); err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Start: write")
	}
	req, err := http.NewRequest(http.MethodPost, c.endpoint+"/remoto/Orchestrator.Start", buf)
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Start: new request")
	}
	req.Header.Set("Accept", "application/json; charset=utf-8")
	req.Header.Set("Content-Type", w.FormDataContentType())
	req = req.WithContext(ctx)
	resp, err := c.httpclient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Start: do")
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, errors.Errorf("OrchestratorClient.Start: remote service returned %s", resp.Status)
	}
	b, err = ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Start: read response body")
	}
	var resps []*Response
	if err := json.Unmarshal(b, &resps); err != nil {
		return nil, errors.Wrap(err, "OrchestratorClient.Start: decode response body")
	}
	return resps, nil
}

type FeedbackRequest struct {
	ID      string `json:"id"`
	Status  bool   `json:"status"`
	Code    int    `json:"code"`
	Message string `json:"message"`
}

type NextRequest struct {
	ID string `json:"id"`
}

type Response struct {
	ID      string `json:"id"`
	IsError bool   `json:"isError"`
	Message string `json:"message"`
	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type RollbackRequest struct {
	ID string `json:"id"`
}

type StartRequest struct {
	Type string `json:"type"`
}

// contextKey is a local context key type.
// see https://medium.com/@matryer/context-keys-in-go-5312346a868d
type contextKey string

func (c contextKey) String() string {
	return "remoto context key: " + string(c)
}

// contextKeyFiles is the context key for the request files.
var contextKeyFiles = contextKey("files")

// file holds info about a file in the context, including
// the io.Reader where the contents will be read from.
type file struct {
	r        io.Reader
	filename string
}

// this is here so we don't get a compiler complaints.
func init() {
	var _ = remototypes.File{}
	var _ = strconv.Itoa(0)
	var _ = ioutil.Discard
}
