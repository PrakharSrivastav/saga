// Code generated by Remoto; DO NOT EDIT.

// Package contract contains the HTTP server for contract services.
package server

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"

	"github.com/machinebox/remoto/go/remotohttp"
	"github.com/machinebox/remoto/go/remotohttp/remototypes"
	"github.com/pkg/errors"
)

type Orchestrator interface {
	Feedback(context.Context, *FeedbackRequest) (*Response, error)

	Next(context.Context, *NextRequest) (*Response, error)

	Rollback(context.Context, *RollbackRequest) (*Response, error)

	Start(context.Context, *StartRequest) (*Response, error)
}

// Run is the simplest way to run the services.
func Run(addr string, orchestrator Orchestrator) error {
	server := New(orchestrator)
	if err := server.Describe(os.Stdout); err != nil {
		return errors.Wrap(err, "describe service")
	}
	if err := http.ListenAndServe(addr, server); err != nil {
		return err
	}
	return nil
}

// New makes a new remotohttp.Server with the specified services
// registered.
func New(
	orchestrator Orchestrator,
) *remotohttp.Server {
	server := &remotohttp.Server{
		OnErr: func(w http.ResponseWriter, r *http.Request, err error) {
			fmt.Fprintf(os.Stderr, "%s %s: %s\n", r.Method, r.URL.Path, err.Error())
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
		NotFound: http.NotFoundHandler(),
	}

	RegisterOrchestratorServer(server, orchestrator)
	return server
}

// RegisterOrchestratorServer registers a Orchestrator with a remotohttp.Server.
func RegisterOrchestratorServer(server *remotohttp.Server, service Orchestrator) {
	srv := &httpOrchestratorServer{
		service: service,
		server:  server,
	}
	server.Register("/remoto/Orchestrator.Feedback", http.HandlerFunc(srv.handleFeedback))
	server.Register("/remoto/Orchestrator.Next", http.HandlerFunc(srv.handleNext))
	server.Register("/remoto/Orchestrator.Rollback", http.HandlerFunc(srv.handleRollback))
	server.Register("/remoto/Orchestrator.Start", http.HandlerFunc(srv.handleStart))

}

type FeedbackRequest struct {
	ID string `json:"id"`

	Status bool `json:"status"`

	Code int `json:"code"`

	Message string `json:"message"`
}

type NextRequest struct {
	ID string `json:"id"`
}

type Response struct {
	ID string `json:"id"`

	IsError bool `json:"isError"`

	Message string `json:"message"`

	// Error is an error message if one occurred.
	Error string `json:"error"`
}

type RollbackRequest struct {
	ID string `json:"id"`
}

type StartRequest struct {
	Type string `json:"type"`
}

// httpOrchestratorServer is an internal type that provides an
// HTTP wrapper around Orchestrator.
type httpOrchestratorServer struct {
	// service is the Orchestrator being exposed by this
	// server.
	service Orchestrator
	// server is the remotohttp.Server that this server is
	// registered with.
	server *remotohttp.Server
}

// handleFeedback is an http.Handler wrapper for Orchestrator.Feedback.
func (srv *httpOrchestratorServer) handleFeedback(w http.ResponseWriter, r *http.Request) {
	var reqs []*FeedbackRequest
	if err := remotohttp.Decode(r, &reqs); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}

	resps := make([]Response, len(reqs))
	for i := range reqs {
		resp, err := srv.service.Feedback(r.Context(), reqs[i])
		if err != nil {
			resps[i].Error = err.Error()
			continue
		}
		resps[i] = *resp
	}
	if err := remotohttp.Encode(w, r, http.StatusOK, resps); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}

}

// handleNext is an http.Handler wrapper for Orchestrator.Next.
func (srv *httpOrchestratorServer) handleNext(w http.ResponseWriter, r *http.Request) {
	var reqs []*NextRequest
	if err := remotohttp.Decode(r, &reqs); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}

	resps := make([]Response, len(reqs))
	for i := range reqs {
		resp, err := srv.service.Next(r.Context(), reqs[i])
		if err != nil {
			resps[i].Error = err.Error()
			continue
		}
		resps[i] = *resp
	}
	if err := remotohttp.Encode(w, r, http.StatusOK, resps); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}

}

// handleRollback is an http.Handler wrapper for Orchestrator.Rollback.
func (srv *httpOrchestratorServer) handleRollback(w http.ResponseWriter, r *http.Request) {
	var reqs []*RollbackRequest
	if err := remotohttp.Decode(r, &reqs); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}

	resps := make([]Response, len(reqs))
	for i := range reqs {
		resp, err := srv.service.Rollback(r.Context(), reqs[i])
		if err != nil {
			resps[i].Error = err.Error()
			continue
		}
		resps[i] = *resp
	}
	if err := remotohttp.Encode(w, r, http.StatusOK, resps); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}

}

// handleStart is an http.Handler wrapper for Orchestrator.Start.
func (srv *httpOrchestratorServer) handleStart(w http.ResponseWriter, r *http.Request) {
	var reqs []*StartRequest
	if err := remotohttp.Decode(r, &reqs); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}

	resps := make([]Response, len(reqs))
	for i := range reqs {
		resp, err := srv.service.Start(r.Context(), reqs[i])
		if err != nil {
			resps[i].Error = err.Error()
			continue
		}
		resps[i] = *resp
	}
	if err := remotohttp.Encode(w, r, http.StatusOK, resps); err != nil {
		srv.server.OnErr(w, r, err)
		return
	}

}

// this is here so we don't get a compiler complaints.
func init() {
	var _ = remototypes.File{}
	var _ = strconv.Itoa(0)
	var _ = io.EOF
}
